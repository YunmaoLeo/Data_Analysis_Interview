# 目录
- [目录](#目录)
  - [SQL](#sql)
    - [排序](#排序)
      - [使用多个列排序，不同的列使用的顺序不同](#使用多个列排序不同的列使用的顺序不同)
      - [使用ORDER BY 和 LIMIT组合获取最N值](#使用order-by-和-limit组合获取最n值)
    - [过滤](#过滤)
      - [WHERE 子句可操作内容](#where-子句可操作内容)
      - [获取范围值：](#获取范围值)
      - [空值检查](#空值检查)
      - [IN操作符](#in操作符)
      - [LIKE 操作符](#like-操作符)
        - [百分号通配符](#百分号通配符)
        - [下划线通配符(_)](#下划线通配符_)
      - [正则表达式搜索](#正则表达式搜索)
        - [匹配字符类](#匹配字符类)
        - [匹配多个实例](#匹配多个实例)
    - [创建计算字段](#创建计算字段)
      - [拼接字段](#拼接字段)
      - [执行算术运算](#执行算术运算)
    - [使用数据处理函数](#使用数据处理函数)
      - [一些字符串函数](#一些字符串函数)
      - [日期和事件处理函数](#日期和事件处理函数)
      - [数值处理函数](#数值处理函数)
    - [汇总数据](#汇总数据)
      - [聚合函数](#聚合函数)
      - [AVG()](#avg)
      - [COUNT()](#count)
      - [聚集不同值](#聚集不同值)
    - [分组数据](#分组数据)
      - [创建分组](#创建分组)
      - [过滤分组](#过滤分组)
      - [分组和排序](#分组和排序)
      - [SELECT子句顺序](#select子句顺序)
    - [联结表](#联结表)
      - [内部链接](#内部链接)
      - [联结多个表](#联结多个表)
    - [创建高级联结](#创建高级联结)
      - [自联结](#自联结)
      - [自然连接](#自然连接)
      - [外部联结 OUTER JOIN](#外部联结-outer-join)
    - [组合查询 UNION](#组合查询-union)
    - [全文本搜索](#全文本搜索)
      - [布尔文本搜索](#布尔文本搜索)
    - [插入数据](#插入数据)
    - [修改数据](#修改数据)
    - [删除数据](#删除数据)
    - [引擎类型](#引擎类型)
    - [MySQL事务](#mysql事务)
    - [更新表](#更新表)
    - [使用视图](#使用视图)
    - [导出数据](#导出数据)
    - [窗口函数](#窗口函数)
      - [按班级分类，将成绩降序排序](#按班级分类将成绩降序排序)
      - [dense_rank() row_number() rank()](#dense_rank-row_number-rank)
      - [查找重复的电子邮件](#查找重复的电子邮件)
      - [CUME_DIST()](#cume_dist)
      - [FIRST_VALUE()](#first_value)
      - [LAG()](#lag)
      - [LEAD()](#lead)
  - [互联网经典sql题](#互联网经典sql题)
  - [统计学知识](#统计学知识)
    - [抽取样本](#抽取样本)
    - [推断统计](#推断统计)
      - [获取P值](#获取p值)
      - [假设检验的三种类型](#假设检验的三种类型)
      - [不同的检验方法](#不同的检验方法)
      - [第一类错误和第二类错误](#第一类错误和第二类错误)
  - [数据分析思维读书笔记](#数据分析思维读书笔记)
    - [业务指标](#业务指标)
    - [如何选择指标](#如何选择指标)
  - [关键词](#关键词)
  - [精益数据分析读书笔记](#精益数据分析读书笔记)
    - [第一章](#第一章)
      - [什么是好的数据指标](#什么是好的数据指标)
      - [如何选择好的指标](#如何选择好的指标)
      - [市场细分 同期群分析 A/B测试和多变量分析](#市场细分-同期群分析-ab测试和多变量分析)
    - [以数据为导向与通过数据获取信息](#以数据为导向与通过数据获取信息)
      - [数据科学家的思维方式：](#数据科学家的思维方式)
    - [数据分析框架](#数据分析框架)
      - [海盗指标：AARRR](#海盗指标aarrr)
      - [增长引擎说](#增长引擎说)
      - [长漏斗](#长漏斗)
    - [第一关键指标的约束力](#第一关键指标的约束力)
    - [商业模式：免费移动应用](#商业模式免费移动应用)
    - [商业模式：用户生成内容（User-generated Content, UGC)](#商业模式用户生成内容user-generated-content-ugc)
    - [用户生成内容：底线在哪里](#用户生成内容底线在哪里)
  - [一些面经收集](#一些面经收集)
    - [比较两款竞品APP](#比较两款竞品app)
    - [主流短视频展现形式对比](#主流短视频展现形式对比)
    - [用户流失预警体系](#用户流失预警体系)
    - [拆解广告收益](#拆解广告收益)
    - [全面阐述常用APP](#全面阐述常用app)
    - [拉新](#拉新)
    - [用户生命周期价值](#用户生命周期价值)
    - [功能效果评估](#功能效果评估)
    - [竞品分析](#竞品分析)
    - [ROI知识点](#roi知识点)
    - [用户留存](#用户留存)
    - [归因分析](#归因分析)
    - [拆解分析和对比分析](#拆解分析和对比分析)
    - [AB实验](#ab实验)
  - [增长黑客：](#增长黑客)
    - [好的产品是增长的本质](#好的产品是增长的本质)
  - [确定增长杠杆](#确定增长杠杆)
  - [快节奏试错](#快节奏试错)
    - [快节奏试验流程：](#快节奏试验流程)
  - [获客](#获客)
  - [激活](#激活)
    - [激活与绘制通往啊哈时刻的路线图](#激活与绘制通往啊哈时刻的路线图)
  - [留存](#留存)
    - [留存框架图](#留存框架图)
  - [变现](#变现)
- [数据分析项目建模的工作流程是怎样的？](#数据分析项目建模的工作流程是怎样的)
- [赤裸裸的统计学](#赤裸裸的统计学)
  - [中心极限定理](#中心极限定理)
  - [统计推断和假设检验](#统计推断和假设检验)
  - [第一类错误第二类错误](#第一类错误第二类错误)
  - [单尾/双尾假设检验](#单尾双尾假设检验)
  - [问卷设置](#问卷设置)
  - [Z-score](#z-score)
  - [P值](#p值)
  - [卡方检验](#卡方检验)
  - [方差分析](#方差分析)
- [游戏数据分析的艺术](#游戏数据分析的艺术)
  - [基于统计学的基础分析方法](#基于统计学的基础分析方法)
    - [度量数据](#度量数据)
      - [统计描述](#统计描述)
## SQL

### 排序
+ ORDER BY默认使用升序排列
#### 使用多个列排序，不同的列使用的顺序不同
```mysql
SELECT prod_id, prod_price, prod_name
FROM product
ORDER BY prod_price DESC, prod_name;
```
+ DESC关键字只应用到直接位于前面的列名

#### 使用ORDER BY 和 LIMIT组合获取最N值
```mysql
SELECT prod_price
FROM products
ORDER BY prod_price DESC
LIMIT 1;
```

### 过滤

#### WHERE 子句可操作内容
|操作符|说明|
|------|----|
|=||
|<>|不等于|
|!=|不等于|
|<||
|<=||
|>||
|>=||
|BETWEEN|指定两个值之间

#### 获取范围值：
```
SELECT prod_name, prod_price
FROM products
WHERE prod_price BETWEEN 5 AND 10;
```
#### 空值检查
```
SELECT prod_name
FROM products
WHERE prod_price IS NULL
```

#### IN操作符
+ IN取的合法值由逗号分隔的清单
```
SELECT prod_name, prod_price
FROM products
WHERE vend_id IN (1002,1003)
ORDER BY prod_name
```
+ IN操作符一般比OR操作符速度更快
+ 此外，IN可以包含其他SELECT语句，能够动态简历WHERE子句

#### LIKE 操作符
+ 通配符搜索花费的时间更多
+ 在确定是要通配符时，除非绝对有必要，不要把他们放在搜索模式的开始处，否则搜索起来是最慢的
##### 百分号通配符
+ %表示任何字符出现的任意次数
+ 以下代码找出所有以词jet开头的铲平
```
SELECT prod_id, prod_name
FROM products
WHERE prod_name LIKE 'jet%'
```
+ 同样，也可以是
```
WHERE prod_name LIKE '%anvil%'
```

##### 下划线通配符(_)
+ 用处与%一样，但是只能匹配单个字符

#### 正则表达式搜索
```
WHERE prod_name REGEXP '1000'
```
+ 如上代码中，如果对应的列中出现了REGEXP后面的字符串，则返回它
+ 正则字符串匹配不区分大小写，如果需要区分可以使用``REGEXP BINARY 'JetPack'``

<br>

+ 正则表达式中要匹配``. -``等特殊字符需要加反义字符``\\``

+ 一些元字符
  + \\f 换页
  + \\n 换行
  + \\r 回车
  + \\t 制表符
  + \\v 纵向制表符

##### 匹配字符类
+ [:alnum:] 任意字母和数字
+ [:aplha:]
+ [:blank:] 空格和制表
+ [:cntrl:] ASCII控制字符 0-31和127
+ [:digit:] 数字
+ [:lower:]
+ [:space:]
+ [:upper:]
+ [:xdigit:]

##### 匹配多个实例
+ * 0个或多个
+ + 1个或多个
+ ? 0个或1个
+ {n} 指定n个匹配
+ {n,} 大于等于n个
+ {n,m} 匹配数目的范围，m不超过255

<br>

+ 匹配连在一起的四位数字：
```
WHERE prod_name REGEXP '[[:digit:]]{4}'
```

+ 简单的正则表达式测试
```
SELECT 'hello' REGEXP '[0-9]'
```
正确会返回1，否则0

### 创建计算字段

#### 拼接字段
+ 使用Concat()函数
```
SELECT Concat(vend_name, '(', vend_country, ')' ) --可以添加字符
FROM vendors
ORDER BY vend_name;
```
+ RTrim()函数实现删除数据右侧多余的空格来整理数据
  + 同样亦可以使用LTrim去掉左边的空格
  + 当然，也可以使用Trim()去掉左右两边的空格
```
SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country) ,')' )
FROM vendors
ORDER BY vend_name;
```

#### 执行算术运算
```
SELECT prod_id,
       quantity,
       item_price,
       quantity*item_price AS expanded_price
FROM orderitems
WHERE order_num = 200005;
```

### 使用数据处理函数
#### 一些字符串函数
+ Upper()将文本转换为大写
+ Left() 返回串左边的字符
+ Length() 返回串的长度
+ Locate() 找出串的第一个字串
+ SubString() 返回字串的字符
+ Soundex() 返回串的SOUNDEX值 （发音相似的）

#### 日期和事件处理函数
+ AddData() 增加一个日期，天周等
+ AddTime() 增加一个时间， 时，分
+ CurDate() 当前日期
+ CurTime() 当前时间
+ DateDiff() 计算两个日期的差
+ Hour()
+ Minute()
+ Month()
+ Now()
+ Second() 返回秒的部分
+ 日期的格式：
  + yyyy-mm-dd

+ 检索一个日期时，
  + 如果要的是日期，一定要使用Date()
```
SELECT cust_id, order_num
FORM orders
WHERE Date(order_date) = '2005-09-01';
```
+ 检索一段时间的
```
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
```

或者

```
WHERE Year(order_date) = 2005 AND Month(order_date) = 9;
```

#### 数值处理函数
+ Abs()
+ Cos()
+ Exp()
+ Mod()
+ Pi()
+ Rand()
+ Sin()
+ Sqrt()


### 汇总数据

#### 聚合函数
+ AVG() 平均值
+ COUNT() 列数
+ MAX()
+ MIN()
+ SUM()

#### AVG()
```
SELECT AVG(prod_price) AS avg_price
FROM products;
```

#### COUNT()
+ 使用COUNT(*)对表中行的数目进行计数，不管包含的是空值还是非空值
+ 使用COUNT(column)对特定列中具有值得行进行计数，忽略NULL
```
SELECT COUNT(*) AS num_cust
FROM customers;
```
+ 上述代码计算所有的数目
+ 以下代码计算cust_emial列中的非空值
```
SELECT COUNT(cust_email) AS num_cust
FROM customers;
```

#### 聚集不同值
+ 如果需要只包含不同的值，指定DISTINCT参数，否则ALL会被作为默认
```
SELECT AVG(DISTINCT prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
```

### 分组数据

#### 创建分组
```
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id
```
+ 如上代码中，groupby将会对vend_id进行排序并分组数据
  + 如果分组列中有NULL值，则NULL会被作为一个分组返回，如果列中有多行NULl值，他们会被分成一组
+ GROUP BY子句必须出现在WHERE之后，ORDER BY之前

+ 使用``WITH ROLLUP``关键字可以得到每个分组以及每个分组汇总级别（针对每个分组）的值
```
GROUP BY vend_id WITH ROLLUP;
```

#### 过滤分组
+ HAVING 子句
  + WHERE过滤行，HAVING过滤分组
  + 同样可以理解为，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤
```
SELECT cust_id, COUNT(*) AS orders
FROM orders
GROUP BY cust_id
HAVING COUNT(*) >= 2; 
```

+ 同时进行WHERE和HAVING
```
SELECT vend_id, COUNT(*) AS num_prods
FROM products
WHERE prod_price >= 10 --首先限制需要的产品价格是10以上的
GROUP BY vend_id
HAVING COUNT(*) >= 2; --然后限制分组后数量需要大于等于2
```

#### 分组和排序
+ 在使用GROUP BY子句的同时，也应该给出ORDER BY子句
  + 这是保证数据正确排序的唯一方法
```
SELECT order_num, SUM(quantity*item_price) AS ordertotal
FROM orderitems
GROUP BY order_num
HAVING SUM(quantity*item_price) >= 50
ORDER BY ordertotal;
```

#### SELECT子句顺序
+ 1. SELECT
+ 2. FROM
+ 3. WHERE
+ 4. GROUP BY
+ 5. HAVING
+ 6. ORDER BY
+ 7. LIMIT

### 联结表

#### 内部链接
```
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
  ON vendors.vend_id = products.vend_id;
```

#### 联结多个表
```
SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems, products, vendors
WHERE products.vend_id = vendors.vend_id
  AND orderitems.prod_id = products.prod_id
  AND order_num = 123;
```
+ 此种关联处理是相当耗费资源的


### 创建高级联结
+ 通过``AS``关键字使用别名，两点好处
  + 缩短SQL语句
  + 允许在单挑SELECT语句中多次使用相同的表

#### 自联结
```
SELECT p1.prod_id, p1.prod_name
FROM products AS p1, products AS p2
WHERE p1.vend_id = p2.vend_id
  AND p2.prod_id = 'DTNTR'
```
+ 如上代码中使用两个相同的表分别作为p1, p2
  + WHERE中选取p2中产品ID为DTNTR的列，此时p2.vend_id就是DTNTR的生产商
  + p1.vend_id = p2.vend_id 此时意味在p1选取DTNTR的生产商

#### 自然连接
+ 无论如何对表进行联结，应该至少有一列出现在不止一个表中。
  + 标准的联结返回所有数据，甚至相同的列多次出现。
  + 自然联结排除多次出现，使每个列只返回一次

#### 外部联结 OUTER JOIN
+ 外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT 或者LEFT关键字指定包括其所有行的表


### 组合查询 UNION
+ UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分割
+ UNION中的每个查询必须包含相同的列，表达式或聚集函数
  + UNION从查询结果中集中自动去除了重复的行
    + 如果不想改变这种默认去除的行为，可以使用UNION ALL

+ 如果需要对组合查询的结果进行排序，只能放在最后一条SELECT语句中ORDER BY，不允许使用多条ORDER BY

### 全文本搜索
+ 创建表的时候使用FULLTEXT(note_text),这里的FULLTEXT索引单个列
  + 在索引之后，使用两个函数Match()指定被搜索的列，Against()指定要使用的搜索表达式

```
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('rabbit');
```
+ 全文本搜索的一个重要部分是对结果排序，具有较高等级的行先返回


#### 布尔文本搜索
```
WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);
```
+ 如上代码中IN BOOLEAN MODE表示使用布尔类型的文本搜索
  + -rope*表示配出包含任何以rope开始的词的行

+ 全文本布尔操作符
  + + 包含，词必须存在
  + - 排除，词不存在
  + > 包含，增加等级值
  + < 不包含，减少等级值
  + ~ 取消排序值
  + * 词尾通配符

### 插入数据
+ 使用INSERT插入数据是很耗时的
+ 为了提高服务器内SELECT语句的性能
  + 使用INSERT LOW_PRIORITY INTO降低INSERT的优先级
    + 同样也适用于UPDATE和DELETE


### 修改数据
```
UPDATE customers
SET cust_email = 'elmer@fudd.com'
WHERE cust_id = 10005;
```

### 删除数据
+ 如果需要从表中删除所有行，不要使用DELETE，
  + 而是使用TRUNCATE TABLE语句，他会删除原来的表并重新创建一个表

### 引擎类型
+ 默认引擎是MyISAM
+ InnoDB是一个可靠的事务处理引擎，支持全文搜索
+ MEMORY在功能等同于MyISAM，但由于数据存储在内存，速度很快，特别适合临时表
+ MyISAM性能极高，支持全文本搜索，但不支持事务处理
+ 然而，混用引擎类型的一个问题就是，外键不可以跨引擎使用


### MySQL事务
+ 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，如果事务过程中发生错误，会被回滚到开始的状态
+ 一致性：事务执行前后，数据库的完整性没有被破坏，这意味着写入的所有信息都要符合预设的规则
+ 隔离性：数据库允许多个并发事务同时进行读写和修改，隔离性可以放置多个事务并发执行时由于交叉执行导致数据不一致
+ 持久性：事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失
+ 使用BEGIN来开始一个事务
+ ROLLBACK事务回滚
+ COMMIT事务确认
+ SET AUTOCOMMIT = 0 禁止自动提交

### 更新表
```
ALTER TABLE vendors
ADD vend_phone CHAR(20)
DROP COLUMN vend_phone;
ADD CONSTRAINT fk_orderitems_orders
FOREIGN KEY (order_num) REFERENCES orders (order_num);
```

### 使用视图
+ 视图不包含表中应该有的任何列或数据，只包含一个SQL查询
+ 视图使用CREATE VIEW语句来创建
+ SHOW CREATE VIEW viewname; 来查看创建视图的语句
+ CREATE OR REPLACE VIEW来更新视图

```
CREATE VIEW productcustomers AS
SELECT cust_name, cust_contact, prod_id
FROM customers, orders, orderitems
WHERE customers.cust_id = orders.cust_id
  AND orderitems.order_num = orders.order_num
```

+ 以上视图联结了三个表，返回了已经订购任意产品的所有客户的列表
```
SELECT cust_name, cust_contact
FROM productcustomers
WHERE prod_id = 'TNT2';
```
+ 或者也可以使用视图来重新格式化出检索出来的数据
```
CREATE VIEW vendorlocations AS
SELECT Concat(RTrim(vend_name), '(',RTrim(vend_country),')')
       AS vend_title
FROM vendors
ORDER BY vend_name
```

### 导出数据
```
SELECT * FROM runoob_tbl
INTO OUTFILE 'runoob.txt'
FIELDS TERMINATED BY ',' ENCLOSED BY ''''
LINES TERMINATED BY '\r\n';
```

### 窗口函数
+ 窗口函数的窗口表示范围，可以理解为将原数据划分范围，及分组，然后用函数实现某些目的
  + 相比于GROUP BY , 窗口函数不会减少原来的行数
+ 语法: SELECT 窗口函数 over (partition by 用于分组的列名，order by 用于排序的列)
+ 专用窗口函数
  + rank(), dense_rank(), row_numer()

#### 按班级分类，将成绩降序排序
```
SELECT *,
rank() over ( PARTITION BY class_id ORDER BY SCORE DESC ) AS ranking
FROM class
```

#### dense_rank() row_number() rank()
+ 三个函数的主要区别是如何处理并列情况
+ rank()中的并列情况会占用下一个名词的位置, 1,1,1,4
+ dense_rank() 不会占用下一个名词 1,1,1,2
+ row_number()中，会忽略并列的情况, 1,2,3,4

#### 查找重复的电子邮件
```
SELECT email, COUNT(email)
FROM contacts_test
GROUP BY email
HAVING COUNT(email)>1
```

+ 删除重复的电子邮件
```
DELETE t1
FROM contacts_test AS t1 INNER JOIN contacts_test AS t2
WHERE t1.id<t2.id AND t1.email = t2.email
```

#### CUME_DIST()
+ 表示值小于等于行的值除以总行数的行数
```
SELECT
name,score,CUME_DIST() OVER (ORDER BY score) cume_dist_val
FROM scores;

```

#### FIRST_VALUE()
+ 选取第一行的数据
```
SELECT employee_name,
       FIRST_VALUE(employee_name) OVER (
         PARTITION BY department
         ORDERED BY hours DESC
       ) least_over_time
FROM overtime;
```

#### LAG()
+ 从同一结果集中的当前行访问上一行的数据
+ 以下代码中返回特定年份和上一年度中每个产品系列的订单:

#### LEAD()
+ 选取当前行的后续行
```
SELECT customerName, orderDate,
       LEAD(orderDate, 1) OVER (
         PARTITION BY customerNumber
         ORDER BY orderDate
       ) nextOrderDate
FROM orders
INNER JOIN customers USING (customerNumber)
```

## 互联网经典sql题
1、用户活跃表：tmp_liujg_dau_based
1）imp_date，日期，string格式，样例20190601
2）qimei，用户唯一标识，string格式，无空值
3）is_new，新用户标识，string，1表示新用户，0表示老用户
说明：以imp_date、qimei为主键，一个用户1天只出现1次，出现即表示当日登陆

2、红包活动参与表：tmp_liujg_packet_based
1）imp_date，日期，string格式，样例20190601
2）report_time，领取时间戳，string格式
3）qimei，用户唯一标识，string格式，无空值
4）add_money，领取金额，string格式，表示领取金额，单位为分，无空值或0值
说明：日志流水表，每一行为领取1次红包。无特殊情况说明，一般不考虑领取红包但

+ 1. 计算出20190601至今，每日DAU（有登陆的用户）
  + 输出维度: imp_date (日期)
  + 输出指标: DAU
```
SELECT imp_date COUNT(qimei) AS DAU
FROM temp_liujg_dau_based
WHERE to_date(imp_date, 'yyyy-mm-dd') > to_date('20190601', 'yyyy-mm-dd')
GROUP BY imp_date
```

+ 2. 计算20190601至今，每日领取红包的新用户书，老用户数，及人均领取金额，人均领取次数
+ 输出维度: imp_date, is_new(新用户1，老用户0，未知2)
+ 输出指标: mean_money(人均领取金额), mean_get_count(人均领取次数)
```
SELECT t2.imp_date, IFNULL(t1.is_new,2),
      COUNT(DISTINCT t2.qimei) user_num,
      SUM(t2.add_money)/COUNT(DISTINCT t2.qimei) mean_money
      COUNT(t2.add_money)/COUNT(DISTINCT t2.qimei) mean_get_count

  (
    SELECT imp_date, qimei, is_new
    FROM tmp_liujg_dau_based
    WHERE to_date(impdate,'yyyy-mm-dd')> to_date(20190601,'yyyy-mm-dd')
  ) t1
  RIGHT OUTER JOIN
  (
    SELECT imp_date, qimei, add_money
    FROM temp_liujg_packet_based
    WHERE to_date(imp_date,'yyyy-mm-dd') > to_date('20190601','yyyy-mm-dd')
  ) t2
  ON t1.imp_date = t2.imp_date AND t1.qimei = t2.qimei
  GROUP BY imp_date, IFNULL(is_new,2)
```

第三问
计算2019年3月，每个月按领红包取天数为1、2、3……30、31天区分，计算取每个月领取红包的用户数，人均领取金额，人均领取次数
输出维度：month（月份），get_money_das（领取天数）
输出指标：user_count（用户数），mean_money(人均领取金额)，mean_get_count(人均领取次数)

第四问
计算2019年3月，每个月领过红包用户和未领红包用户的数量，平均月活跃天数（即本月平均活跃多少天）
输出维度：month（月份），is_packet_user(红包用户1，非红包用户0)
输出指标：user_count(用户数量)，mean_days_in_month(月活跃天数)

第五问
计算2019年3月至今，每个月活跃用户的注册日期，2019年3月1日前注册的用户日期填空即可
输出维度：month（月份），qimei(用户唯一标识)
输出指标：register_date（注册日期）

第六问
计算2019年3月至今，每日的用户次日留存率，领取红包用户的次日留存，未领取红包用户的次日留存率
输出维度：imp_date（日期）
输出指标：dau(当日用户数)，retain_rate（次日留存率）
，packet_user_retain_rate（当日领红包用户次日留存率），unpacket_user_retain_rate（当日未领红包用户次日留存率）

第七问
计算2019年3月1日至今，每日新用户领取的第一个红包的金额
输出维度：imp_date（日期），qimei（用户唯一标识）
输出指标：money（第一个红包的金额）

第八问
计算2019年3月1日至今，每个新用户领取的第一个红包和第二个红包的时间差（只计算注册当日有领取红包的用户，注册当日及以后的DAU表中新用户为1的用户）
输出维度：imp_date（注册日期），qimei(用户唯一标识)
输出指标：first_action_time（首次领红包时间），second_action_time（第二次领红包时间），delta_times（时间差）

第九问
计算2019年6月1日至今，每日领取红包用户领取金额的中位数
输出维度：imp_date（日期）
输出指标：mid_money（用户当日领取红包金额的中位数）

+ 3. 计算某一天的 N日留存率
```
CREATE TABLE `user_login`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `u_id` int(11) NOT NULL,
  `log_day` date NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
)
```
```
SELECT t1.log_day,
  COUNT(DISTINCT t1.user_id)
  COUNT(DISTINCT t2.user_id)/COUNT(DISTINCT t1.user_id) AS 次日留存率
FROM
  (
    SELECT user_id, log_day
    FROM user_login
    WHERE log_day = '2021-01-01' AND u_id NOT IN
                                      (
                                        SELECT DINSTINCT user_id
                                        FROM user_login
                                        WHERE log_day < '2020-01-01'
                                        #这之前没有进行过登录的
                                      )
  ) t1
  LEFT OUTER JOIN user_login t2
    ON t1.user_id = t2.user_id AND DATEDIFF(t2.log_day,t1.log_day) = 1
GROUP BY t1.log_day
```
SELECT job,ROUND(AVG(score),3) AS avg
FROM grade
GROUP BY job
ORDER BY avg DESC

+ 4. 计算每日用户留存率
```
SELECT a.dayno as Date,
COUNT(DISTINCT a.uid) as ActUsers,
COUNT(DISTINCT CASE WHEN DATEDIFF(b.dayno,a.dayno) =1 then b.uid else null end) as 1DayLeft
concat(round(...,2),'%') AS LeftRate
FROM
  (SELECT * FROM act_user_info where app_name = 'xiangji') a LEFT JOIN
  (SELECT * FROM act_user_info where app_name = 'xiangji') b
  ON a.uid = b.uid
GROUP BY a.dayno
```

SUM(VALUE) OVER(PARTITION BY FYEAR ORDER B MONTH) AS YSUM,


+ 查询每个用户最近一次登陆的记录即每个用户的登陆总次数
```

```


## 统计学知识

### 抽取样本
+ 样本均值的抽样分布近似服从正态分布，且样本量越大，近似性越强
+ 样本量大于30的时候符合中心极限定理，样本服从正态分布，样本量小于30的时候，总体近似正态分布，样本服从t分布

### 推断统计
+ 提出假设
+ 确定显著性水平
+ 选择检验统计量
+ 建立决策准则
+ 下结论

#### 获取P值
+ 首先计算样本标准差StandardError: 样本标准差/sqrt(n) n:样本的大小
+ t = (样本值-总体均值)/标准误差

#### 假设检验的三种类型
+ 单样本检验：检验单个样本的平均值是否等于目标值
+ 相关匹配检验：检验相关或配对检测之差的平均值是否等于目标值
+ 独立双样本检验：检验两个独立样本的平均值之差是否等于目标值

#### 不同的检验方法
+ Z检验：用于大样本平均值差异性检验的方法，用标准正态分布的理论来推断差异发生的概率
+ T检验：用于样本含量较小，总体标准差未知的正态分布样本
+ F检验：方差齐性检验，在两个样本t检验中要用到F检验，检验两个样本的方差是否有显著性差异
  + T检验用来检测数据的准确度，检测系统误差；F检验用来检测数据的精密度，检测偶然误差
+ 卡方检验：主要用于检验两个或两个以上样本率或构成比之间的差别的显著性，可用于检验两类事物之间存在一定的关系

#### 第一类错误和第二类错误
+ 第一类错误是拒绝了实际正确的假设
+ 第二类错误是接受了实际上不成立的假设
+ 当置信水平高的时候，总体值均值落在置信区间的可能性就更大，这个时候不容易拒绝正确的假设，但更容易接受不成立的假设
+ 实际过程中我们更害怕第一类错误，所以会尽可能设置高的置信水平


## 数据分析思维读书笔记
### 业务指标
+ 用户数据指标
  + 日新增用户数：各渠道来源
  + 活跃率：活跃用户数/总用户数
  + 留存率：第一天新增用户中，在第N天使用过产品的用户数
    + 次日留存率40， 7日20， 30日10是比较好的
+ 行为数据指标
  + PV：Page View 访问次数
  + UV：Unique Visitor 访问人数 
  + 转化率：广告转化率：点击广告的人数/看到广告的人数
  + K因子：
    + K因子等于平均每个用户像多少人发出邀请 * 接收到邀请的人转化为新用户的转化率
    + K因子用来衡量推荐的效果，K>1，新增用户数就会像滚雪球一样增大
+ 产品数据指标
  + 总量
    + GMV成交总额
    + 成交数量
    + 访问市场
  + 人均
    + 人均付费APRU
    + 付费用户人均付费ARPPU
    + 人均访问时长
  + 付费
    + 付费率
    + 复购率

### 如何选择指标
+ 要找出正确的指标要记得五点：
  + 1. 定性指标与定量指标的收集整理和分析
    +  定性数据吸纳主观因素，定量数据排斥主观因素
  + 2. 虚荣指标与可付诸行动的指标的判别
    + 比如总用户数就是个虚荣指标，因为它值会随着时间增长，类似的，还有总活跃用户数
    + 而活跃用户占总用户数的百分比，就是个可付诸行动指标
    + 其他的还有需要提防的虚荣指标还有：
      + 点击量，页面浏览量，赞的数量，网站停留时间，下载量
  + 3. 探索性指标与报告性指标
  + 4. 先见性指标和后见性指标
    + 前者预测未来，后者提示当前问题所在
  + 5. 相关性指标与因果性指标


## 关键词
PEST、4P、5W2H、SWOT、公式化思维、下钻分析思维、逻辑树思维、对比思维、费米思想、RFM模型、漏斗模型、AARRR模型、用户生命周期模型、熵权法、TGI分析法、双重差分法、AHP层次分析法、拐点法、Abtest、用户画像、增长黑客、北极星指标、OSM指标体系构建。


## 精益数据分析读书笔记

### 第一章
``无论你的妄想多么有说服力，都经不起数据的严格考验``  
``你可以通过直觉得知需要设计何种试验来测试你的创业假设，然后利用数据来验证这些假设``

#### 什么是好的数据指标
+ 简单易懂
+ 是一个比率
  + 比率可操作性强，是行动的向导
  + 是天生的比较性指标，如果将日数据和月数据进行比较，就是会知道该数据当前经历的是短期还是长期的变化
  + 比率还适用于比较各种因素之间的关联（正相关和负相关）
+ 会改变行为

#### 如何选择好的指标
+ 要找出正确的指标要记得五点：
  + 1. 定性指标与定量指标的收集整理和分析
    +  定性数据吸纳主观因素，定量数据排斥主观因素
  + 2. 虚荣指标与可付诸行动的指标的判别
    + 比如总用户数就是个虚荣指标，因为它值会随着时间增长，类似的，还有总活跃用户数
    + 而活跃用户占总用户数的百分比，就是个可付诸行动指标
    + 其他的还有需要提防的虚荣指标还有：
      + 点击量，页面浏览量，赞的数量，网站停留时间，下载量
  + 3. 探索性指标与报告性指标
  + 4. 先见性指标和后见性指标
    + 前者预测未来，后者提示当前问题所在
  + 5. 相关性指标与因果性指标
    + 因果关系测试：找到一个相关性，进行控制变量实验并测量因变量的变化

#### 市场细分 同期群分析 A/B测试和多变量分析
+ 市场细分
  + 简单来说细分市场就是一群拥有相同特征的人
+ 同期群分析
  + 比较相似群体随时间的变化，或是，根据用户的体验来划分数据
+ A/B和多变量测试
  + 假设其他条件不变，仅考虑体验中的某一属性，如链接的颜色，对被试用户的影响，就是A/B测试
  + A/B测试看似简单易行，实际上，只有用户流量巨大的大型网站，能对单一因素进行测试并迅速得到答案。
  + 进行一连串的单独测试会延长你走向成熟的周期，与其如此，不如采用多变量分析法同时对多个属性进行测试
    + 多变量分析法的原理就是，用统计学方法剥离出单个影响因子与结果中某一指标提升的相关性

### 以数据为导向与通过数据获取信息
+ ``人类提供灵感，机器负责验证``

#### 数据科学家的思维方式：
+ 1. 要懂得为数据去除噪声，虽然耗时，但回报通常是很大的
+ 2. 不要忘记归一化
+ 3. 不要轻易排除异常点
+ 4. 异常点也不能全然保留
+ 5. 不要忽略季节性，要重视时间规律的影响
+ 6. 不要抛开技术谈增长
+ 7. 数据呕吐：如果你不知道什么数据对你重要，多大的数据统计版都没有意义
+ 8. 谎报军情的指标：不要设置太多的警报
+ 9. 把数据和其他来源的数据合在一起能带来很多独到的见解
+ 10. 人类与生俱来的模式识别能力，容易使我们误以为无规律的事物是有规律的，把虚荣指标放在一边，退后一步，站在更高的角度看问题

### 数据分析框架

#### 海盗指标：AARRR
+ AARRR：获取用户，提高活跃度，提高留存率，获取营收和自传播

#### 增长引擎说
+ 黏着式增长引擎
  + 其重点在于让用户成为回头客，并且持续使用你的产品
  + 如果你的用户粘性不大，流失率会很高。
  + ``用户参与度是预测产品成功的最佳指示剂之一``
  + 衡量粘性最重要的KPI就是``客户留存率，流失率，使用频率``
  + 长期粘性往往来自用户在使用产品过程中为自身所创造的价值
+ 病毒式增长引擎
  + 病毒式传播之所以吸引人，在于它的指数性本质，如果每个用户能带来1.5个新用户，那么用户数会无限地增长到饱和
  + 其中的一个关键指标是``病毒式传播系数``, 及每个用户带来的新用户
  + 同时还需要衡量``病毒传播周期（循环）``
    + 比如，大部分社交网络都会在注册的时候问你是不是要同步通讯录，然后诱导你邀请他们。还有就是用户完成一次邀请所需的时间
+ 付费式增长引擎
  + 第三种驱动增长的引擎是消费，在确定产品有黏着性和病毒性前开动这个引擎是比较仓促的行为。
    + 机甲世界这款游戏中先专注于提高使用量，黏着性，然后致力于游戏的病毒性，最后才是付费，让玩家通过购买增值服务提升游戏体验
  + 赚钱本身不是一个驱动增长的引擎，只有把一部分营收再用于获取客户时，营收才有助于增长
  + 业务增长机器上有两个调节旋钮，分别是``客户终生价值(CLV)``和``客户获取成本(CAC)``：客户盈亏平衡时间：收回获取一位客户的成本所需的时间


#### 长漏斗
+ 长漏斗是一种分析方法，可以帮助我们理解最初是如何获得客户的注意力的，以及客户从最初得知该网站到发生你所期望的行为的全过程。
  + 在整个漏斗的全阶段进行监控，这样用户在网站中走到哪儿，追踪到哪儿
    + 比如注册获取通知邮件，点击商品页面，查看评价，和客服对话

### 第一关键指标的约束力
+ 在数据分析的世界里，挑选一个唯一的指标，该指标对你当前所处的创业阶段无比重要，我们称之为``OMTM(One Metric That Matters, 第一关键指标)``
+ 你可以捕捉所有的数据，但只关注其中重要的那些

### 商业模式：免费移动应用
+ 重要指标
  + 下载量
  + 客户获取成本（CAC）
  + 应用运行率
    + 有多少下载的用户真正开启了该项应用
  + 活跃用户数量比率和日活DAU，月活MAU
  + 付费用户率
  + 首次付费时间
    + 用户激活后需要多久才会开始付费
  + 用户平均每月营收ARPU
    + 购买和广告的收入总和的平均
    + 这个指标可以给出我们真实的用户参与度。通常是以月为单位计算的
  + 点评率，在应用商店评分或评论的用户比例
  + 病毒性
    + 每位用户可以邀请多少新用户
  + 流失率
    + 卸载应用或在一定时间段内没有开启过应用的用户比例
  + 客户终身价值
    + 用户在使用应用期间贡献的营收
    + 测算每位流失用户的平均消费金额
+ 比如现在每月流失用户占总用户数的15%，这意味着平均每位玩家的游戏寿命是（1/0.15），6.67个月
  + 付费用户比例，了解付费人群和非付费人群之间的差异很重要
    + 假设知道某种广告吸引进来的用户更可能花费，那么就应该多打些类似的广告
  + 流失率：跟踪一日，一周，一月
    + 一日可能是软件的使用体验过于糟糕，有明显的问题
    + 产品使用起来新鲜感很快就结束了，不够耐玩
    + 产品有更好的替代品，或者是规划处理得不好  
+ 一个软件的大部分营收可能来自于一小部分用户，应该将部分用户单独划分一组进行分析处理，虽然关键指标是平均每位用户营收，但最好同时跟踪平均每位付费用户营收，因为这些特殊用户和其他大部分用户的行为想法往往相差甚远

### 商业模式：用户生成内容（User-generated Content, UGC)
+ 此类商业模式重点关注优质内容的生成
+ UGC指优质内容和糟糕内容之间以及内容生成者和潜水者之间的比例，这是一个参与度漏斗，与传统电商的转化漏斗十分相似。
  + 二者的区别在于，转化漏斗的目的是让大家买东西，而参与度漏斗旨在让用户提高参与度，让潜水者参与投票，投票者参与评论等
+ 应该关注的关键指标
  + 访客参与度：
    + 衡量这一指标地简易方法是计算一个比值
      + 在今天的访客里，曾经在本周早些时候访问过该网站的人数的比例，不论有没有创建过帐户
  + 另一个指标是距离上次访问/点赞/评论/发视频的平均时间
  + 活跃访客数
    + 访客回访频率，以及每次来访的停留时间
  + 内容生成与互动
    + 以某种方式与内容进行互动的访客比例，包括生成内容以及顶/踩行为
  + 参与度漏斗的变化
    + 应用是否有效地增加了用户参与度
    + 按月为单位或用户群展示漏斗内容，重要级别高的内容放在下面
  + 生成内容的价值
    + 内容的商业价值
    + 最好按照用户群或流量来源分开比较，这样可以提高获取新用户的投资收益比
  + 内容分享和病毒性
    + 内容是如何被分享的
    + 用于了解有没有达到足够的病毒式传播水平
    + 需要了解内容的分享方式和分享人群
    + 有助于了解是否应该考虑将付费门槛作为变现策略
  + 消息提醒的有效性
    + 看到推送通知、邮件通知或其他提醒时，给与回应的用户比例

### 用户生成内容：底线在哪里
+ 内容上传成功率
  + 对于这样的功能要持续优化，直到所有用户都能使用它
+ 平均每日应用停留时间

## 一些面经收集
### 比较两款竞品APP
+ 抖音和快手
  + 相似处：都是基于用户画像去做个性化推荐
  + 区别
    + 抖音的logo是音乐 slogan是记录美好生活
      + 更倾向于结合音乐去打造一种比较美好，比较潮流酷炫的视频
    + 快手的logo是一个摄像机的图标，slogan记录纪录世界纪录你
      + 强调通过摄像头纪录平凡的生活
  + 使用上的差异：
    + 都是瀑布流，但快手会更倾向于双排列
      + 瀑布流推动沉浸式的体验，让用户消费的更爽
      + 快手会更注重封面的内容
  + 作为产品设计的角度看区别
    + 主要针对的用户群体
      + 抖音鼓励优质创作者创造高质量视频，集中在一二线城市，男女比例相当
      + 快手更加平民化，更本土气息，下沉市场，男性比例居多
      + 流量分发模式不同
        + 快手更注重大家的参与度
        + 抖音的流量分配会更加集中，分配到那些有优质的博主
        + 同时，两个软件其实在互相学习
  + 未来发展方向
    + 电商
      + 抖音：短视频变现，让用户看完视频之后购买链接，现在也有电商直播了
      + 快手：强调和用户之间建立信任，通过直播来带货

### 主流短视频展现形式对比
+ 瀑布式排列和双排列
  + 瀑布流
    + 用户体验更爽，更能实现kill time消磨时间的目的
      + 与此同时，用户更多的处于一种被投喂的状态，用户被动接受系统推荐，不需要去做主动选择
    + 风险：对推荐算法提出了更高的要求，如果推荐算法的效果不够理想，带来的用户体验感是很低的
  + 双排列
    + 让用户看到自己想看到的内容，在这种模式下让用户需要花费更多时间进行选择
    + 风险：如果视频博主的内容很好，但封面做的不太好，可能会倒置好的视频没有被分发到流量，另一方面也可能会产生标题党，封面党一类降低使用体验的情况
+ 具体选择哪种模式
  + 1. 设置页面开关，让用户自行选择
  + 2. A/B实验
    + 选取什么样的指标
      + 留存率，日活等
      + 用户行为指标
        + 点赞评论收藏转发
        + APP的使用时长（消费程度）
        + 视频的完播率，播放完整度
        + 跳出率：用户点进视频就立刻退出

### 用户流失预警体系
+ 滴滴的用户流失预警指标
+ 从用户角度进行考虑会涉及哪些指标内容
  + 用户周均使用频次的环比变化率
  + 使用体验度的平均打分
  + 用户叫车的平均等待时间
+ 用户行为指标
  + 乘客角度
    + 进入APP之后的行为路径
      + 注册账号-登录-打车-评论
    + 打车过程中
      + 等待时长
      + 用户使用频次
      + 消费红包的使用情况
    + 评论
  + 司机角度
    + 注册账号
    + 登陆账号
    + 验证身份：关键
    + 开始接单

+ 搭建一个完整的用户流失预警体系
  + 1. 观察窗口
    + 确立指标，观察指标变化
  + 2. 表现窗口
    + 在一定的时间窗口内定义已流失用户的用户画像，行为特征，生命周期
      + 然后不断地优化模型来提高流失规则集地覆盖率和命中率
  + 3. 预测窗口
    + 在未来几周或几个月内进行预测，对于没流失的用户进行预测，给不同的用户群体打分，区分高中低风险的流失用户

### 拆解广告收益
+ 微信朋友圈的广告收益如何拆解/电商广告分析
  + 1. 按收入基本公式拆解
    + （DAU * 人均VV * ad load)/1000 * CPM
      + 日活x人均浏览量x广告信息密度x平均每用户广告展示成本
      + 日活涉及到两个方面
        + 用户质量，用户会不会去消费，消费的能力如何
        + 可展示广告日活，日活中有多少比例的人是可以被展示广告的
      + 广告信息密度
        + 平衡用户侧和商业化侧的指标，平衡用户体验和商业变现需求
      + CPM千人展示成本
        + 需要丰富广告主结构，对广告主进行分层次的讨论
  + 2. 按照请求拆解
    + 请求总量x填充率x展现率x平均每位用户广告展现成本
      + 请求总量
        + 根据广告间隔，每刷多少次朋友圈会获得一次广告
        + 根据时间间隔，平均多少时间会展示一个广告
      + 填充率反映的是平台销售能力，是否有足够多的客户
  + 3. CPC方式
    + 请求总量x填充率x展现率x点击报价x点击率
+ 实际上在用户最终看到广告之前是需要先经过一些漏斗环节的
  + 第一个环节：微信朋友圈发出需要广告的需求，然后广告库发送过来进行填充广告的行为

### 全面阐述常用APP
+ 1. 作为视频软件 使用体验如何，清晰度高，使用流畅
+ 2. 作为视频平台 不仅仅是消费者，也是视频的生产者，高质量博主不断产生，好的内容生态，用户间交流体验好
+ 3. 作为广告推荐平台 推荐的广告内容是贴合用户个人需求，投放质量高
+ 4. 生活中的应用场景多，不论是娱乐休闲还是专业知识学习，可以高频率的在生活中出现，可以提高用户粘性
+ 5. 阐述缺点：站内视频的资源非常多，所有时候视频质量良莠不齐，PC端查看并没有好的推荐页面，只有手机端可以有推荐页面
  + 无法在PC端获得瀑布式+双排列式的沉浸式体验
  + 审核机制需要提升，大量的重复，抄袭内容

### 拉新
+ 1. 市场拉新策略
  + 投入比较多
  + 线上广告拉新
    + SEM搜索引擎营销，会有广告标识
      + 会根据用户搜索的精确度进行区分
    + DSP广告，广告需求平台
      + 信息流广告
  + 线下地推:
    + 公交站地铁站传单
      + 先做前期调研
      + 缺点是要求人力，受地点限制，流失率比较高
  + KOL和APP之间的合作
  + 不同APP之间的合作，京东和爱奇艺的联名卡
+ 2. 运营拉新策略
  + 裂变拉新
    + 比较有创意性的活动，推动用户自己传播分享APP
    + PDD砍一刀
  + 推送拉新
    + 精细化推荐，对用户画像的研究要求很高
+ 3. 产品本身的拉新策略
  + 新产品中内置邀请码，推广码，一键分享的功能，优化功能

### 用户生命周期价值
+ Lifetime Value
  + 从用户接触的第一天到流失的那一天创造的净利润
  + LTV = LT * ARPU
+ 用户生命周期价值预测
  + 1. LT=1+次日+2日+...+N日留存率
    + 对于LT的预测其实就是对于留存率衰减的一个预测，可能会误差
    + 选其一定时期内的ARPU均值作为计算表的，但并不合理
  + 2. 从用户交易成交预测出发
    + LTV = 付费用户LT * ARPU * 付费转化率
    + 缺点：估算存在很大的误差，付费转化率通常会受到产品策略的较大影响
  + 3. 搭建时间序列模型
    + 按照LTV的历史数据拟合未来的发展趋势
      + 对历史数据量要求更高，天数越多，预测精度越高
### 功能效果评估
+ 1. 功能是否受用户欢迎
  + 该功能的活跃用户比
    + 一段时间内的使用用户数/日活用户数
+ 2. 功能涉及的流程转化率
  + 针对搜索功能的子功能优化
    + 这个功能所涉及到的转化流程漏斗，在哪一个环节的转化率出现了变化
+ 3. 关注该功能的使用留存
  + 一个功能上线之后用户第N天还来使用这个功能
  + 有的功能刚上线用的人很多，但是留存率很少
+ 4. 深入研究用户是如何使用这个功能的
  + 每个人的使用习惯不一样
  + 满足多样化的用户的偏好
  + 用户访谈，用户调研
+ 5. 与预期目标进行对比

### 竞品分析
+ 意义：明确下一阶段的目标和业务上的侧重点
  + 学习其他同类产品的优势，规避发生过的问题和风险
+ 如何展开竞品分析
  + 确定竞品
    + 美团外卖的竞品 针对某一APP内可以实现的功能去找同类竞品，而不是整体
    + 直接竞品和间接竞品
  + 明确比较的维度
    + 性能 用户 作者
  + 各种方式和第三方数据平台获取数据
  + 进行对比
    + 数据比较
    + 矩阵分析 SWOT PEST 波特五力
  + 输出竞品分析报告

### ROI知识点
+ ROI是一个增量意义指标
  + 收入-成本/成本
  + 或是 收入/成本
+ 针对营销活动的指标
  + 代金券/优惠券活动的ROI评估
  + 成本是代金券的总金额
  + 收入就是订单的总金额
  + 激励用户去使用这些APP
+ 内容营销活动的ROI评估
  + 品牌方和当下热门活动的视频推广，内容营销
  + 推出节目后销售额变化
  + 传播数据
  + 互动数据，互动人数，社交媒体的搜索情况
  + 转化率：展现质量层面 阅读量的价值
    + 各个渠道的转化率的估算
    + 往期同类活动的转化率水平

### 用户留存
+ 时间越长，用户的留存就会随之降低
+ 使用周期
  + 根据不同的产品设定留存周期
+ 拆解分析
  + 用户划分
    + 1. 新老用户的划分
    + 2. 渠道
    + 3. 消费能力
  + 三个阶段
    + 短期阶段 震荡期
    + 中期阶段 选择期 培养用户使用产品的习惯
    + 长期阶段 平稳期 产品能带来的价值
      + 关注产品商业变现和用户付费

### 归因分析
+ 提交订单 五个入口
  + 每个位置对应提交订单次数/总订单次数
+ 难点在于如何确定观测什么动作，观测什么位置
  + 1. 末次互动归因法
    + 将最终取得收益的功劳100%归到最后一步作用于收益的环节上
      + 适用于业务周期短
      + 漏斗转化少
  + 2. 首次互动归因法
    + 无法考虑到后续整体的用户行为路径
      + 适用于发展初期
      + 品牌扩张期
      + 获取用户了解对应渠道效果
  + 3. 位置归因法
    + 将首次互动和末次互动进行结合，各分配了40%的权重，剩下的20%分在其中其他部分
  + 4. 以时间为粒度：时间衰减归因方法
    + 时间越短的渠道贡献越大
    + 只适用于业务周期短的情况
  + 5. 线性归因
    + 误差会很大

### 拆解分析和对比分析
+ 把综合性问题进行拆解
+ 产品详情页到完成支付转化率下降
  + 1. 判断数据真实性
  + 2. 拆解数据指标
  + 3. 综合内外部因素进行分析
+ 1. 确认转化率的下降是一种异常的下降还是正常的波动
  + 和自身同比环比对比
  + 和同行业，历史数据进行对比
+ 2. 如何分析指标下降
  + 转化率 = 完成支付的用户人数/进入详情页的用户人数
  + 随后根据用户进行群体拆解，不同的用户人群针对分析


### AB实验
+ 来源于假设检验
+ 同质样本组的对照试验
+ 辛普森悖论
  + 分别讨论时都满足某种性质，但放在一起就不满足了
  + 划分子数据集的时候没有对流量进行一个合理的分割
  + 用了1%的流量进行试验，但上线后得到的效果是相反的
    + 需要样本量能够代表实际的总体特征

+ 统计中显著，实际中不显著
  + 选取的样本量过大
+ 统计不显著，怎么判断收益
  + 将指标拆分成每一天进行观察，获取曲线情况
+ 关注的指标显著提升，就可以上线吗
  + 此种指标提升有可能会影响别的部门或者是别的业务的影响，要查看这种影响对整体的影响，进行综合评估。

## 增长黑客：

### 好的产品是增长的本质
+ 寻找你产品使用户眼前一亮的时刻，让用户觉得不可或缺，好的产品才是增长的根本
+ 不应该太早开展增长攻势：
  + 没有人会喜欢一个不合格的产品
  + 时间和成本浪费在了错误的事情上，病毒传播是一个双刃剑
  + 要定位产品的核心价值，是对产品的喜爱创造了增长，不是增长创造了爱
+ 找到产品的啊哈时刻：
  + 能够让用户眼前一亮，不可或缺
+ 产品的不可或缺性调查：
  + 了解产品不够理想的原因
  + 竞品可以提供但是你不能提供的体验
+ 调查的目标群体
  + 调查用户基数越多越好，可靠性越高，信息量越丰富
  + 最好是活跃用户而不是休眠用户
  + 确定我们的产品是否已经具备了核心价值
+ 衡量用户留存
+ 成为不可或缺的产品
  + 走进用户的现实世界
  + 寻找受访群体，与用户交流，让产品获得更强的吸引力
  + 快速试错
    + 既可以是较复杂的产品改进实验，也有很容易执行的信息传达和营销实验
    + 改进信息传达的方式
      + A/B测试
+ 深挖数据
  + 构建数据仓库
  + 跟踪活跃用户行为，发现他们的特质
  + 实现啊哈时刻
    + 推特用户的啊哈时刻就是可以看到明星、政客等发布状态

+ 如果我们发现自己的产品的价值与原本自己规划或者料想的完全不同，那么我们就可能需要重新定位自己的产品，让它成为符合用户期待的不可或缺之物
+ 挖掘啊哈时刻的手段有两种：
  + 1. 用户问卷调查与数据深挖
    2. 对客户体验漏斗的整个过程开展体验，从客户认知到获取，到客户激活、留存、变现、自传播
  + 比如推特发现他们的用户的啊哈时刻是收到朋友、明星、政客等他们看中的人发布的状态，于是推特设计了全新的用户入门体验，他们引入推荐功能，并放置在用户注册的流程内，让他们的用户一注册结束就有了一批自己感兴趣的关注对象。



## 确定增长杠杆

+ 创造并让更多用户体验到啊哈时刻是破解增长难题的第一步，下一步是明确增长战略。这时候我们需要通过一套十分严谨科学的方法来明确我们的增长方向，找出增长杠杆
+ 明确增长策略：
  + 严密的测试流程，专注于实现目标
  + 高影响力实验，带来更大成功，也能够更快产生明确结果
+ 真正重要的指标：
  + 选定北极星指标：
    + 增长公式中那一个变量最能反应产品不可或缺体验的实现情况
    + 清晰明确的北极星指标能够使数据分析具有很强的针对性
  + 指标要根据具体情况作出调整和改变
  + 不要偏离路线
    + 要对负责的产品保持绝对的冷静客观，不带有情感
  + 数据不是唯一的
    + 要有定性分析和定量分析的结合
  + 简洁明了的报告

+ 所有的产品都有几个共同的推动因素，比如新用户获取、高激活率和高留存率

## 快节奏试错
+ 增长的循环包含了以下过程：
  + 提出想法
  + 排定优先级
  + 测试
  + 反馈分析
  + 提出想法

### 快节奏试验流程：
+ 缓慢起步，逐步提速：一开始启动太多实验会导致执行效果不够好
+ 准备工作
  + 1. 分析
    + 我们的最佳客户有哪些行为（用户行为信息）？
    + 我们的最佳客户有哪些特征（用户个人特征）？
    + 流失用户都有哪些特征，流失的原因有哪些？
  + 2. 提出想法
    + 说明清楚应该做出什么具体的改变
    + 建立想法库，想法越多，就越有机会找到刺激增长的绝佳方法
  + 3. 排定优先级：
    + Impact, Confidence, Ease ICE评分：影响力，信心， 简易性
    + Time, Impact, Resource TIR评分：时间，影响力，资源
    + Potential, Importance, Ease PIE评分：潜力，重要性和简易性
  + 4. 测试
      + 采用99%的置信水平
      + 永远以对照组为依据
  + 重回分析与学习
+ 增长会议
  + 1. 回顾指标并更新关注领域
  + 2. 回顾一周测试工作
  + 3. 从试验分析中获得的主要收获
  + 4. 选择下一个周期的增长试验
  + 5. 检查增长想法储备库

## 获客
+ 获客
  + 语言-市场匹配
    + 产品优势描述能否打动目标用户
  + 渠道-产品匹配
    + 渠道对目标用户推广的时候有效程度如何
+ 设计打动人心的广告语
  + 用户的注意力是非常短的，平均只有8秒
  + 迎合，点燃需求和欲望，抓住注意力
  + 通过A/B测试，视觉网站优化器，衡量比较用户反映
  + 广告语优化品牌
+ 寻找最优渠道
  + 缩小渠道范围！
    + 不要盲目建立分销渠道
    + 不要随波逐流，跟随别人的渠道
  + 对所有可以考虑的渠道建立正确的认知
  + 了解用户行为类型
  + 通过测验找到渠道
    + 考虑因素涵盖：成本，定向，控制，时间投入，产出时间与规模
+ 设计病毒循环
  + 在好包装和好内容之间取得平衡
  + 避免调入陷阱
    + 骗用户去做他们通常不会做的行为，这就叫做黑暗模式
      + 黑暗模式短期内是凑效的，但长期抵制情绪会被最终拖垮
    + 病毒系数：
      + 病毒系数(K) = 客户发出的邀请数*受邀者中接受邀请的人数比例
+ 挖掘产品的网络效应：创造和产品核心价值契合的激励机制
  + 匹配奖励：推荐人、被推荐者都可以获得奖励
  + 现金奖励
  + 分享邀请成为用户体验的有机组成

## 激活
+ 绘制通往啊哈时刻的路线图，根据每个步骤的用户行为数据来找到那些会阻碍用户前往啊哈时刻的阻碍，并快速实验来验证、改进它。

### 激活与绘制通往啊哈时刻的路线图
+ 创建转化和流失漏斗报告：
  + 全程跟踪抵达激活时刻之前用户的所有关键步骤
  + 跟踪访客接触产品的途径或渠道
+ 用户调查注意事项
  + 满足两个主要条件
    + 用户活动要能够反映出用户的困惑
    + 用户刚刚完成很多人没有完成的步骤
  + 有开放式提问，让客户畅所欲言
  + 不要问太多问题
+ 优化新用户摩擦
  + 带给用户与产品独一无二的邂逅
    + 传达相关性，展示产品价值，提供明确的行为召唤
    + 翻转漏斗：先体验产品带来的乐趣
  + 消除用户体验中的摩擦 欲望-摩擦=转化
+ 优化与阻力的角力
  + 积极的摩擦：把更有趣，更令人着迷的环节放到访客面前
    + 帮助他们明白产品的价值，让他们带着更大的可预测性去体验啊哈时刻
  + 游戏开发者
    + 不要太难，人们会更倾向继续行动
    + 简单的小步骤让用户开始游戏
    + 激励！这可以训练人们条件反射式地去做某个行为
  + 创造学习流：鼓励他们去参与产品内的活动，比如推特就是鼓励他们关注名人，完善资料，关注感兴趣的话题
  + 游戏机制化的利与弊
    + 利：挑战和乐趣，星巴克
    + 弊：过度使用触发物
    + 有意地触发，通知优惠，新功能通知，顶级用户奖励
    + 行为 = 动机+能力+触发物
  + 可汗学院在创造新的纪录还会获得新的惊喜，但是它也明白学习过程中掌握技能本身所带来的成就感才是内在奖励

## 留存
+ 亚马逊的留存是一个经典案例，免费试用用户成为付费用户，第一年订购会员用户的续订比例达91%，时间越长，留存越高
+ 留住用户的时间越长，从他们身上获得更多收益的机会就越大
  + 他们可以推动口碑营销和病毒式营销，因为用户使用产品的时间越长，就越有可能谈论、推荐它
+ 应该密切关注数据，一旦使用率下滑，可以进行快速测试，锁定重新唤醒客户的最佳做法

### 留存框架图
+ 留存的三个阶段：
  + 初期：让新用户在特定时间内重复获得新体验
  + 中期：让用户养成习惯，让产品变成他们生活的一部分
  + 长期：确保产品为用户带来更大的价值
+ 确定跟踪群组：
  + 加大营销活动效果，渠道变化，特定人群变化等
+ 实际的、体验式的汇报
  + 强调帮你节约钱，购物券代金券等礼物
  + 比如会员升级 贵宾室休息 优先值机
+ 认可用户成就
+ 客户关系个性化
+ 控制节奏
  + 新产品发布、什么时候续订、再购买
+ 保持长期活跃
  + 优化产品功能 推送以及重复使用的奖励
  + 定期推出新功能
  + 警惕功能膨胀！
+ 持续用户引导
  + 弄清楚如何让用户沿着学习曲线前行
  + 爬坡：实现小目标-提高熟练程度-学习进程嵌入新功能-获得价值
  + 检测用户行为，通过一个决策引擎来决定推送内容，然后跟踪用户完成了哪些行为，适当时候引导用户开始新的行为
  + 复活僵尸用户：了解离开的原因-设计新邮件、重定向广告，来鼓励用户重新安装
+ 一些公司的留存方式：
  + Yalp: 激励用户写更多的评论，获得更多的徽章，建立品牌大使计划
  + 美国运通黑卡：是一种身份的象征

## 变现
+ 绘制变现漏斗：深度分析用户流失点，通过实验找出产品的弱点
+ 分析付费用户行为数据，找出付费的动力在哪里，有一定的目标后尝试使用快速实验验证
+ 根据企业自身特征，将用户通过其创造收益的高低，所在地点、年龄和性别等特征进行群组分组，并对其行为数据进行群组跟踪的分析方式，关注各群组的贡献
+ 通过问卷调查，直接了解用户的需求，通过快速实验优化我们的定价
+ 寻找夹点
  + 找出产品、网站、App中有搞创收价值的页面和功能
  + 利用数据/算法为用户定制产品和功能
+ 关注每个群组的贡献  认识、调查我们的用户
+ 优化定价
  + 1. 动态定价
    + 亚马逊会根据购买历史，季节性规律，存量，使用电脑类型来调整并测试价格变化，最后找出最大的购买量，实利润最大化的价格
  + 2. 定价相对论
    + 用户愿意付多少钱很大程度上收到价格选项组合的影响
  + 3. 一分钱的差距：
    + 免费-广告收入-升级解锁
    + 97%的免费项目+3%的付费项目
    + 付费用户可以打开的高级功能
    + 用户并不一定像你想象的那样敏感
  + 4. 注意事项
    + 小心翼翼的推进
    + 注意隐私边界

# 数据分析项目建模的工作流程是怎样的？
+ 1. 确定我们需要解决的问题，概览一下整体情况
+ 2. 获取数据并且进行探索性的数据分析来获得更多信息
  + 缺失值、属性之间的关联度、对我们的目标的作用，数值的分布情况
+ 3. 让数据更好的契合我们的机器学习模型，进行标准化（平均值变成0，标准差变成1）、归一化（数据映射到0~1, -1~1)之间，标准化/归一化是一种线性变换，不会让数据本身的表现失效，反而可以提高表现的效果，梯度下降方法收敛求最优质的时候速度更快
+ 4. 探索各种不同的模型训练数据，选取出表现比较好的几个
+ 5. 微调模型并把他们整合成一个最好的结果
+ 6. 展示结果，输出报告


# 赤裸裸的统计学

## 中心极限定理
> 有时，我们能够通过少量数据抽样调查或的结论，这一力量实际上来自中心极限定理。
+ 中心极限定理的活动都是使用样本对一个更大的数量对象进行推理，比如民意调查或者是不良率检测。
+ 核心要义：一个大型样本的正确抽样与其所代表的群体存在相似关系，尽管每个样本之间肯定存在差异，但是任一样本和整体之间存在巨大差异的概率是比较低的。
  + 中心极限定理告诉我们，样本的平均值会围绕着群体平均值形成一条正态分布曲线。而样本本身的分布情况并不重要，经验告诉我们，样本数量必须要达到30，才能成立中心极限定理
+ 标准误差用来衡量样本平均值的离散型，计算标准误差可以知道这些样本平均值到底离得近还是远。$ SE=s/\sqrt{n} $ 标准误差等于总体标准差除以根号样本数量

## 统计推断和假设检验
+ 设立一个零假设，通过证明零假设不成立来反应对立的假设成立。
+ 如果支撑数据的结果大于我们设定的显著性水平0.05，那么就称这个假设是有意义的。

+ 我们可以使用Z检验对均值、均值间差异、比例做假设检验
+ 在我们不知道总体标准差的时候，我们就使用t检验，分母上是样本标准差，T分布的形态会更矮，两边尾部更厚


## 第一类错误第二类错误
+ 在电子邮件过滤中
  + 零假设：任何一封电子邮件都不是垃圾邮件
  + 第一类错误指 让不是垃圾邮件的电子邮件也被屏蔽掉了
  + 第二类错误指 让垃圾邮件通过筛选进入到了收件箱里面

+ 第一类错误：假阳性，我们认为检测到了效果，但是实际上没有
+ 第二类错误：假阴性：有一个影响，我们只是没有看到他
更多时候我们更宁愿选择1类错误，而不是2类错误

## 单尾/双尾假设检验

## 问卷设置

+ 题目选项设置应该是全面的
+ 题目描述应该是中性的

## Z-score

+ 比较两个不同的事物，比较考试SAT和ACT的人，尺度不同
+ 首先，我们将每个分数都减去测试的平均值，让两个分布的中心都放在0附近，用标准差的单位来衡量均值的距离（再把数据除以标准差）
+ Z分数可以帮助我们比较两个有不同分布的事物，只要是正态分布的。

## P值
+ P值可以告诉我们零假设为真的情况下，数据有多罕见

## 卡方检验
+ 观测到的值和我们期望得到的值，把他们的差异的平方除以期望再相加
+ 两个变量之间是否互相影响
+ 两个样本之间是否都来自同一个群体

## 方差分析
+ 测试多组之间的差异，用分类变量来预测连续变量
+ 一个因素的变化对实践的影响
+ 比如，可可豆的类型对巧克力评级的影响

+ F-test



# 游戏数据分析的艺术

## 基于统计学的基础分析方法

### 度量数据

#### 统计描述
+ 数据的分布特征可以从三个方面进行描述
  + 1. 分布的集中趋势，数据向中心值聚拢的程度
  + 2. 分布的离散程度，数据远离中心值得趋势
  + 3. 分布的形状，反应数据分布的偏态和峰态

+ 几何平均数
  + N个变量值成积的N次方根，适合用于计算现象的平均增长率
    + 如果需要避免很多数相乘让计算结果太大或者接近零，可以用对数变换

+ 要比较不同样本数据的离散程度时，可以使用变异系数
  + 变异系数是``标准差除以平均数``，变异系数越大，说明数据离散程度越大

+ 正态分布
  + 一条钟形对称曲线，关于均值对称，分布的均值决定中心的位置，分布的标准差决定钟型曲线的宽度。
+ 密度曲线图
  + 也叫核密度估计，在大数据集上更接近我们所期望的理论分布，能够提示数据潜在的形状，其平滑度可以帮助发现数据的结构